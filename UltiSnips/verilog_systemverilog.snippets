extends fpga

snippet `in
\`include "${1:uvm_macros.svh}"
endsnippet

snippet import  "import package"
import   ${1:uvm_pkg}::*;
\`include "uvm_macros.svh"
endsnippet

snippet ffp "posclk sequential logic"
always_ff @ (posedge clk) begin
    $0
end
endsnippet	

snippet ffn "neg sequential logic"
always_ff @ (negedge ${1:clk}) begin
    $0
end
endsnippet

snippet comb "combination logic"
always_comb begin
    ${1:/*code*/}
end
endsnippet

snippet latch "D latch"
always_latch
begin
    ${1:/*code*/}
end
endsnippet

snippet inside "a inside x"
${1:/*var*/} inside ${2:/*var*/}
endsnippet

snippet log  "logic"
logic                       ${1:inport};
endsnippet

snippet logb "logic  [xx:00]"
logic   [${1:MSB}:00]             ${2:inport};
endsnippet

snippet in      "input logic  inport"
input   logic               ${1:inport},
endsnippet

snippet inb     "input wire [MSB:0] inport"
input   logic   [${1:MSB}:00]     ${2:inport},
endsnippet

#output
snippet our    "logic  xxx"
output  logic               ${1:outport},
endsnippet

snippet outr    "logic  [MSB:00]"
output  logic   [${1:MSB}:00]     ${2:outport},
endsnippet

snippet package
package ${1:name};
endpackage
endsnippet

snippet state   "one hot encode machine state"
localparam              IDLE    = 0;
localparam              OVER    = 1;
(* KEEP = "TRUE" *)reg    [OVER:00]        cs = 'd1, ns = 'd1;
reg     [15:00]         state_cnt;

// synthesis translate_off
reg [127:0] cs_STRING;
always @(*)
begin
    case(1'b1)
        cs[IDLE]: cs_STRING = "IDLE";
        cs[HEAD]: cs_STRING = "HEAD";
        default: cs_STRING = "XXXX";
    endcase
end
// synthesis translate_on

always_ff @(posedge clk)
begin
    if(rst)
        cs <= 'd1;
    else
        cs <= ns;
end

always_comb @(*)
begin
    ns = 'd0;
    case(1'b1)
        cs[IDLE]:
        begin
            if(/*condition*/)
                ns[/*next_state*/] = 1'b1;
            else
                ns[IDLE] = 1'b1;
        end
        cs[HEAD]:
        begin
            if(/*condition*/)
                ns[/*next_state*/] = 1'b1;
            else
                ns[HEAD] = 1'b1;
        end
        default:
            ns[IDLE] = 1'b1;
    endcase
end


always_ff @ (posedge clk)
begin
    if(rst)
    begin
    end
    else
    begin
        case (1'b1)
            ns[IDLE]:
            begin
                /*code*/
            end
            /*code*/
            default:
            begin
                /*code*/
            end
        endcase
    end
end

always_ff @ (posedge clk)
begin
    if(rst)
        state_cnt <= 0;
    else if (cs != ns)
        state_cnt <= 0;
    else
        state_cnt <= state_cnt + 1'b1;
end
endsnippet

#######################################################################
######################   SIM          #################################
#######################################################################
snippet interface   "use it like module"
interface ${1:name} 
(
  $0
);
endinterface
endsnippet

snippet clocking    "clocking block"
clocking ${1:cb} @ (posedge clk);
input   #${2:time}  /*signal*/;
output  #${3:time}  /*signal*/;   
endclocking
endsnippet

snippet modport  "modport"   
modport ${1:master}
(
    input                       ${2:clk},
    output                      ${2:clk},
);
endsnippet

snippet struct  "typedef struct"
typedef struct packed
{
    /*data*/;
}${1:/*struct*/}_s;
endsnippet

snippet union     "typedef union"
typedef union packed
{
    /*data*/;
}${1:/*union*/}_u;
endsnippet

snippet foreach
foreach(${1:name}[${2:index}]) begin
  $0
end
endsnippet

snippet fork "join"
fork
  begin
    ${1:thread}
  end
$0
endsnippet

snippet task    "task template"
task ${1:task name}(${2:argument list});
  $0
endtask
endsnippet

snippet function     "function template"
function ${1:return type} ${2:func name}(${3:argument list});
  $0
endfunction
endsnippet

snippet assert  "assert ... else"
assert(${1:condition})
else $error(${2:failed});
endsnippet

snippet enum "typdef enum"
typedef enum
{
  $0
}${1:type name};
endsnippet


snippet covergroup "covergroup basic template"
covergroup ${1:name};
  option.name = $1;
  $0
endgroup
endsnippet

snippet coverpoint "coverpoint template"
${1:name} : coverpoint ${2:name}
{
  $0
}
endsnippet

#######################################################################
######################   UVM          #################################
#######################################################################

snippet uvm_info    "print info"
\`uvm_info("${1:class_name}", $sformatf("${2:info}"), UVM_LOW);
endsnippet

snippet uvm_fatal    "fail sim"
\`uvm_fatal("${1:class_name}", $sformatf("${2:info}"));
endsnippet

snippet uvm_error    "report error"
\`uvm_error("${1:class_name}", $sformatf("${2:info}"));
endsnippet

snippet uvm_component_utils "register component"
\`uvm_component_utils(${1:class_name});
endsnippet

snippet uvm_object_utils "register object"
\`uvm_object_utils(${1:class_name});
endsnippet

snippet uvm_config_db "set - get"
uvm_config_db#(${1:type})::${2:set or get}(this, "*", "${3}", ${4});
endsnippet

snippet uvmobj "UVM object (extends uvm_object)" b
class ${1:my_obj} extends uvm_object;
  `uvm_object_utils(${1})

  $0
  function new(string name = "${1}");
    super.new(name);
  endfunction : new
endclass : ${1}
endsnippet

snippet uvmcomp "UVM component (extends uvm_component)" b
class ${1:my_comp} extends uvm_component;
  `uvm_component_utils(${1})

  $0
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction : new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction : build_phase

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
  endfunction : connect_phase

  task run_phase(uvm_phase phase);
  endtask : run_phase

endclass : ${1}
endsnippet

snippet uvmobjx "UVM object extending a base object" b
class ${1:my_obj} extends ${2:uvm_object};
  `uvm_object_utils(${1})

  function new(string name = "${1}");
    super.new(name);
  endfunction : new

endclass : ${1}
endsnippet

snippet uvmcompx "UVM component extending a base component" b
class ${1:my_comp} extends ${2:uvm_component};
  `uvm_component_utils(${1})

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction : new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction : build_phase

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
  endfunction : connect_phase

  task run_phase(uvm_phase phase);
  endtask : run_phase

endclass : ${1}
endsnippet

snippet uvmobjpx "Param UVM object extending a base (uses `uvm_object_param_utils`)" b
class ${1:my_obj} #(
  type ${2:T} = int $0
) extends ${3:uvm_object};
  `uvm_object_param_utils(${1} #(${2}))

  function new(string name = "${1}");
    super.new(name);
  endfunction : new

endclass : ${1}
endsnippet

snippet uvmcomppx "Param UVM component extending a base (uses `uvm_component_param_utils`)" b
class ${1:my_comp} #(
  type ${2:T} = int $0
) extends ${3:uvm_component};
  `uvm_component_param_utils(${1} #(${2}))

  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction : new

  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
  endfunction : build_phase

  function void connect_phase(uvm_phase phase);
    super.connect_phase(phase);
  endfunction : connect_phase

  task run_phase(uvm_phase phase);
  endtask : run_phase

endclass : ${1}
endsnippet
